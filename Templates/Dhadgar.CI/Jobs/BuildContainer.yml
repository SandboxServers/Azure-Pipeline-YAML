# Build Container Job
# Builds Docker image for a service using pre-built artifacts from Build stage
# Saves image as tarball artifact for PublishContainer job
#
# Process:
# 1. Downloads pre-built artifacts from Build stage
# 2. Copies artifacts into build context (.docker-artifacts/) so Docker can access them
# 3. Passes relative artifact path to Dockerfile via BUILD_ARTIFACT_PATH build arg
# 4. Builds image and saves as tarball
#
# Depends on the Build job completing successfully for this service

parameters:
  service:
    id: ''
    projectPath: ''
    deploy: ''
  acrServiceConnection: ''
  acrLoginServer: ''

jobs:
  - job: BuildContainer_${{ replace(parameters.service.id, '.', '_') }}
    displayName: 'Build Container: ${{ parameters.service.id }}'
    condition: succeeded()
    pool:
      name: 'Sandbox Servers Agents'
    variables:
      serviceName: ${{ replace(lower(parameters.service.id), 'dhadgar.', '') }}
      imageName: dhadgar/${{ replace(lower(parameters.service.id), 'dhadgar.', '') }}
      dockerfilePath: src/${{ parameters.service.id }}/Dockerfile
      artifactName: src-${{ replace(parameters.service.id, '.', '_') }}
    steps:
      - checkout: self
        fetchDepth: 1

      # Download pre-built artifact from Build stage
      - task: DownloadPipelineArtifact@2
        displayName: 'Download build artifact'
        inputs:
          artifact: $(artifactName)
          path: '$(Pipeline.Workspace)/artifacts/$(artifactName)'

      # Copy artifacts into build context so Docker can access them
      - pwsh: |
          $artifactName = "$(artifactName)"
          $artifactSource = "$(Pipeline.Workspace)/artifacts/$artifactName"
          $artifactDest = "$(Build.SourcesDirectory)/.docker-artifacts/$artifactName"

          Write-Host "Copying artifacts from $artifactSource to $artifactDest"
          New-Item -ItemType Directory -Force -Path $artifactDest | Out-Null
          Copy-Item -Path "$artifactSource/*" -Destination $artifactDest -Recurse -Force

          Write-Host "Artifacts copied successfully"
          Write-Host "##vso[task.setvariable variable=DockerArtifactPath].docker-artifacts/$artifactName"
        displayName: 'Copy artifacts into build context'

      # Determine Dockerfile path based on project structure
      # Prefers Dockerfile.pipeline (artifact-based) over Dockerfile (local build)
      - pwsh: |
          $projectPath = '${{ parameters.service.projectPath }}'
          $projectDir = Split-Path $projectPath -Parent
          $serviceName = '${{ replace(parameters.service.id, 'Dhadgar.', '') }}'

          # Priority order:
          # 1. Dockerfile.pipeline (artifact-based, for CI/CD)
          # 2. Dockerfile (local build, fallback)
          $searchPaths = @(
            (Join-Path $projectDir "Dockerfile.pipeline"),
            (Join-Path $projectDir "Dockerfile"),
            "src/Dhadgar.$serviceName/Dockerfile.pipeline",
            "src/Dhadgar.$serviceName/Dockerfile",
            "src/$serviceName/Dockerfile.pipeline",
            "src/$serviceName/Dockerfile"
          )

          $dockerfilePath = $null
          foreach ($path in $searchPaths) {
            if (Test-Path $path) {
              $dockerfilePath = $path
              break
            }
          }

          if (-not $dockerfilePath) {
            Write-Error "No Dockerfile found in: $($searchPaths -join ', ')"
            exit 1
          }

          Write-Host "Using Dockerfile: $dockerfilePath"
          Write-Host "##vso[task.setvariable variable=DockerfilePath]$dockerfilePath"
        displayName: 'Resolve Dockerfile path'

      # Check if Dockerfile exists and needs updating for artifact-based builds
      - pwsh: |
          $dockerfilePath = "$(DockerfilePath)"
          $content = Get-Content $dockerfilePath -Raw

          # Check if this Dockerfile is already artifact-aware
          if ($content -match 'FROM.*AS\s+build' -and $content -notmatch 'COPY.*Pipeline\.Workspace') {
            Write-Warning "Dockerfile at $dockerfilePath appears to rebuild from source."
            Write-Warning "Consider updating it to use pre-built artifacts from Pipeline.Workspace."
            Write-Host "##vso[task.logissue type=warning]Dockerfile rebuilds from source - consider using artifact-based build"
          }
        displayName: 'Validate Dockerfile'
        continueOnError: true

      - task: Docker@2
        displayName: 'Build image'
        inputs:
          containerRegistry: ${{ parameters.acrServiceConnection }}
          repository: $(imageName)
          command: 'build'
          Dockerfile: $(DockerfilePath)
          buildContext: '$(Build.SourcesDirectory)'
          arguments: '--build-arg BUILD_ARTIFACT_PATH=$(DockerArtifactPath)'
          tags: |
            $(Build.BuildId)
            latest

      # List images to debug what was built
      - pwsh: |
          Write-Host "Available Docker images:"
          docker images
        displayName: 'List Docker images'

      # Save image as tarball for PublishContainer job
      - pwsh: |
          $imageName = "$(imageName)"
          $buildId = "$(Build.BuildId)"
          $acrLoginServer = "${{ parameters.acrLoginServer }}"

          # Docker@2 with containerRegistry param tags with ACR prefix
          $imageTag = "${acrLoginServer}/${imageName}:${buildId}"
          $tarballPath = "$(Build.ArtifactStagingDirectory)/container-$(serviceName)-$(Build.BuildId).tar"

          Write-Host "Saving image $imageTag to $tarballPath"
          docker save -o "$tarballPath" "$imageTag"

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to save Docker image"
            exit 1
          }

          Write-Host "Image saved successfully"
          Write-Host "##vso[task.setvariable variable=ImageTarball;isOutput=true]$tarballPath"
        name: saveImage
        displayName: 'Save image as tarball'

      # Publish tarball as pipeline artifact
      - task: PublishPipelineArtifact@1
        displayName: 'Publish container image'
        inputs:
          targetPath: '$(Build.ArtifactStagingDirectory)'
          artifactName: container-${{ replace(parameters.service.id, '.', '_') }}
          publishLocation: 'pipeline'

      # Output image reference for downstream jobs
      - pwsh: |
          $imageRef = "${{ parameters.acrLoginServer }}/$(imageName):$(Build.BuildId)"
          Write-Host "Built image: $imageRef"
          Write-Host "##vso[task.setvariable variable=ImageRef;isOutput=true]$imageRef"
        name: imageOutput
        displayName: 'Output image reference'

      # Clean up Docker images to save disk space
      - pwsh: |
          $imageName = "$(imageName)"
          $buildId = "$(Build.BuildId)"
          $acrLoginServer = "${{ parameters.acrLoginServer }}"

          Write-Host "Cleaning up Docker images to save disk space..."

          # Only remove the BuildId-tagged image (not latest, which may be deployed)
          # Use --no-prune to keep layers that other images might be using
          $buildIdImage = "${acrLoginServer}/${imageName}:${buildId}"

          Write-Host "Removing image: $buildIdImage"
          docker rmi "$buildIdImage" --no-prune 2>&1 | Out-Null

          if ($LASTEXITCODE -eq 0) {
            Write-Host "Successfully removed $buildIdImage"
          } else {
            Write-Host "Image $buildIdImage not found or already removed (this is okay)"
          }

          # Prune only dangling images (untagged intermediate layers)
          # This is safe - won't remove images in use by containers
          Write-Host "Pruning dangling images..."
          docker image prune -f

          Write-Host "Docker cleanup complete"
        displayName: 'Clean up Docker images'
        condition: always()
        continueOnError: true
