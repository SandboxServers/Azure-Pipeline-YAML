# Publish Container Job
# Loads Docker image from tarball artifact and pushes to ACR
# Only runs on non-PR builds
# Uses deployment job with environment for approval gates
#
# Depends on BuildContainer job completing successfully

parameters:
  service:
    id: ''
    projectPath: ''
    deploy: ''
  acrServiceConnection: ''
  acrLoginServer: ''

jobs:
  - deployment: PublishContainer_${{ replace(parameters.service.id, '.', '_') }}
    displayName: 'Publish Container: ${{ parameters.service.id }}'
    condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
    environment: 'meridian-acr-publish'
    pool:
      name: 'Sandbox Servers Agents'
    variables:
      serviceName: ${{ replace(lower(parameters.service.id), 'dhadgar.', '') }}
      imageName: dhadgar/${{ replace(lower(parameters.service.id), 'dhadgar.', '') }}
      containerArtifactName: container-${{ replace(parameters.service.id, '.', '_') }}
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: none

            # Download container tarball from BuildContainer job
            - task: DownloadPipelineArtifact@2
              displayName: 'Download container artifact'
              inputs:
                artifact: $(containerArtifactName)
                path: '$(Pipeline.Workspace)/containers'

            # Load image from tarball
            - pwsh: |
                $tarballPath = Get-ChildItem -Path "$(Pipeline.Workspace)/containers" -Filter "*.tar" | Select-Object -First 1 -ExpandProperty FullName

                if (-not $tarballPath) {
                  Write-Error "Container tarball not found in $(Pipeline.Workspace)/containers"
                  exit 1
                }

                Write-Host "Loading image from $tarballPath"
                docker load -i "$tarballPath"

                if ($LASTEXITCODE -ne 0) {
                  Write-Error "Failed to load Docker image"
                  exit 1
                }

                Write-Host "Image loaded successfully"
              displayName: 'Load image from tarball'

            # Tag image for ACR if not already tagged
            - pwsh: |
                $imageName = "$(imageName)"
                $buildId = "$(Build.BuildId)"
                $acrLoginServer = "${{ parameters.acrLoginServer }}"

                $localTag = "${imageName}:${buildId}"
                $remoteTag = "${acrLoginServer}/${imageName}:${buildId}"
                $remoteLatest = "${acrLoginServer}/${imageName}:latest"

                Write-Host "Tagging image for ACR:"
                Write-Host "  Local: $localTag"
                Write-Host "  Remote (BuildId): $remoteTag"
                Write-Host "  Remote (latest): $remoteLatest"

                docker tag "$localTag" "$remoteTag"
                docker tag "$localTag" "$remoteLatest"

                if ($LASTEXITCODE -ne 0) {
                  Write-Error "Failed to tag image"
                  exit 1
                }

                Write-Host "Image tagged successfully"
              displayName: 'Tag image for ACR'

            # Push image with BuildId tag
            - task: Docker@2
              displayName: 'Push image (BuildId tag)'
              inputs:
                containerRegistry: ${{ parameters.acrServiceConnection }}
                repository: $(imageName)
                command: 'push'
                tags: $(Build.BuildId)

            # Push image with latest tag
            - task: Docker@2
              displayName: 'Push image (latest tag)'
              inputs:
                containerRegistry: ${{ parameters.acrServiceConnection }}
                repository: $(imageName)
                command: 'push'
                tags: latest

            # Output final image reference
            - pwsh: |
                $imageRef = "${{ parameters.acrLoginServer }}/$(imageName):$(Build.BuildId)"
                Write-Host "Published image: $imageRef"
                Write-Host "##vso[task.setvariable variable=ImageRef;isOutput=true]$imageRef"
              name: imageOutput
              displayName: 'Output published image reference'

            # Clean up Docker images to save disk space
            - pwsh: |
                $imageName = "$(imageName)"
                $buildId = "$(Build.BuildId)"
                $acrLoginServer = "${{ parameters.acrLoginServer }}"

                Write-Host "Cleaning up Docker images to save disk space..."

                # Only remove the BuildId-tagged image (not latest, which may be deployed)
                # Check if image is in use by a container first
                $buildIdImage = "${acrLoginServer}/${imageName}:${buildId}"

                # Check if any containers are using this image
                $containersUsingImage = docker ps -a --filter "ancestor=$buildIdImage" --format "{{.ID}}" 2>$null

                if ($containersUsingImage) {
                  Write-Host "Image $buildIdImage is in use by containers, skipping removal"
                } else {
                  Write-Host "Removing image: $buildIdImage"
                  docker rmi "$buildIdImage" --no-prune 2>&1 | Out-Null

                  if ($LASTEXITCODE -eq 0) {
                    Write-Host "Successfully removed $buildIdImage"
                  } else {
                    Write-Host "Image $buildIdImage not found or already removed (this is okay)"
                  }
                }

                # Prune only dangling images (untagged intermediate layers)
                # This is safe - won't remove images in use by containers
                Write-Host "Pruning dangling images..."
                docker image prune -f

                Write-Host "Docker cleanup complete"
              displayName: 'Clean up Docker images'
              condition: always()
              continueOnError: true
