# Standalone Security Scanning Stage Template
# Free/open-source security tools for any .NET/Docker pipeline
# Updated: 2026-01-15 - Added Microsoft Security DevOps integration
#
# Usage Example:
#   - template: Templates/Standalone/Stages/Security.yml
#     parameters:
#       stageName: 'SecurityScan'
#       displayName: 'Security Scanning'
#       dependsOn: ['Build', 'Package']
#       pool:
#         name: 'MyAgentPool'
#       containerArtifacts:
#         - name: 'container-gateway'
#           imageName: 'dhadgar/gateway'
#       scaTarget: 'Dhadgar.sln'
#       nvdApiKey: $(NVD_API_KEY)
#
# Scanning Categories:
# - SAST: Semgrep for code analysis
# - SCA: OWASP Dependency-Check for dependency CVEs
# - Container: Trivy for image vulnerabilities
# - IaC: Checkov for infrastructure security
# - Secrets: GitLeaks for exposed credentials
# - SBOM: Syft for Software Bill of Materials
#
# Results Published To:
# 1. GitHub PR Comments (PostToGitHubPR job) - Requires GITHUB_PAT variable
# 2. SARIF SAST Scans Tab (auto-detected from artifacts) - Requires extension
# 3. Microsoft Security DevOps (PublishToSecurityDevOps job) - Requires extension

parameters:
  # Stage configuration
  stageName: 'Security'
  displayName: 'Security Scanning'
  dependsOn: ['Build']
  condition: succeeded()
  pool:
    name: Sandbox Servers Agents
  
  # Paths (use pipeline variables)
  sourceDirectory: '$(Build.SourcesDirectory)'
  artifactStagingDirectory: '$(Build.ArtifactStagingDirectory)'
  pipelineWorkspace: '$(Pipeline.Workspace)'
  buildId: '$(Build.BuildId)'

  # Container artifacts to scan: [{ name: 'artifact-name', imageName: 'repo/image' }]
  containerArtifacts: []

  # SAST Configuration
  runSast: false
  sastConfig: 'p/security-audit'  # Use Semgrep registry config (can't use 'auto' with metrics off)
  sastSeverities: ['ERROR', 'WARNING']

  # SCA Configuration
  runSca: false
  scaTarget: ''  # Path to .sln or directory
  scaFailOnCvss: 7  # 7=HIGH, 9=CRITICAL, 11=never fail
  nvdApiKey: ''

  # Container Scanning
  runContainerScan: false
  containerSeverities: 'HIGH,CRITICAL'

  # IaC Scanning
  runIacScan: false
  iacFrameworks: 'dockerfile kubernetes helm terraform'

  # Secret Scanning
  runSecretScan: false
  secretScanDepth: 1  # Git history depth (0=full, 1=shallow)

  # SBOM Generation
  runSbom: false
  sbomFormats: 'spdx-json cyclonedx-json'

  # Failure behavior
  failOnCritical: true
  continueOnError: false

stages:
  - stage: ${{ parameters.stageName }}
    displayName: ${{ parameters.displayName }}
    dependsOn: ${{ parameters.dependsOn }}
    condition: ${{ parameters.condition }}
    jobs:
      # Job 1: SAST (Semgrep)
      - ${{ if eq(parameters.runSast, true) }}:
        - job: SAST
          displayName: 'SAST: Semgrep'
          pool: ${{ parameters.pool }}
          steps:
            - checkout: self
              fetchDepth: 1
            - download: none

            - pwsh: |
                Write-Host "Running Semgrep..."
                semgrep scan `
                  --config '${{ parameters.sastConfig }}' `
                  --sarif `
                  --output "${{ parameters.artifactStagingDirectory }}/semgrep.sarif" `
                  --no-git-ignore `
                  2>&1 | Out-Null

                if ($LASTEXITCODE -ne 0) {
                  Write-Warning "Semgrep found issues (exit code: $LASTEXITCODE)"
                }
              displayName: 'Run Semgrep'
              continueOnError: true

            - task: PublishPipelineArtifact@1
              displayName: 'Publish SAST results'
              inputs:
                targetPath: '${{ parameters.artifactStagingDirectory }}/semgrep.sarif'
                artifactName: 'security-sast-semgrep'
              condition: always()

      # Job 2: SCA (OWASP Dependency-Check)
      - ${{ if eq(parameters.runSca, true) }}:
        - job: SCA
          displayName: 'SCA: OWASP Dependency-Check'
          pool: ${{ parameters.pool }}
          steps:
            - checkout: self
              fetchDepth: 1
            - download: none

            - pwsh: |
                $nvdKey = '${{ parameters.nvdApiKey }}'
                $nvdArg = if ($nvdKey) { "--nvdApiKey", $nvdKey } else { @() }

                # Create data directory for OWASP DB
                $dataDir = "/azp/_work/dependency-check-data"
                if (-not (Test-Path $dataDir)) {
                  New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
                }

                Write-Host "Scanning: ${{ parameters.scaTarget }}"
                dependency-check `
                  --project "SecurityScan" `
                  --scan "${{ parameters.scaTarget }}" `
                  --data "$dataDir" `
                  --format "SARIF" `
                  --format "HTML" `
                  --out "${{ parameters.artifactStagingDirectory }}/dependency-check" `
                  --failOnCVSS ${{ parameters.scaFailOnCvss }} `
                  @nvdArg
              displayName: 'Run OWASP Dependency-Check'
              continueOnError: true
              timeoutInMinutes: 30

            - task: PublishPipelineArtifact@1
              displayName: 'Publish SCA results'
              inputs:
                targetPath: '${{ parameters.artifactStagingDirectory }}/dependency-check'
                artifactName: 'security-sca-owasp'
              condition: always()

      # Job 3: Container Scanning (Trivy) - parallel per container
      - ${{ if eq(parameters.runContainerScan, true) }}:
        - ${{ each artifact in parameters.containerArtifacts }}:
          - job: ContainerScan_${{ replace(artifact.name, '-', '_') }}
            displayName: 'Container: ${{ artifact.imageName }}'
            pool: ${{ parameters.pool }}
            steps:
              - checkout: none
              - download: none

              - task: DownloadPipelineArtifact@2
                displayName: 'Download container artifact'
                inputs:
                  artifactName: ${{ artifact.name }}
                  targetPath: '${{ parameters.pipelineWorkspace }}/containers'

              - pwsh: |
                  $tarball = Get-ChildItem "${{ parameters.pipelineWorkspace }}/containers" -Filter "*.tar" | Select-Object -First 1
                  if (-not $tarball) {
                    Write-Error "Container tarball not found"
                    exit 1
                  }

                  Write-Host "Loading container image from: $($tarball.FullName)"
                  $loadOutput = docker load -i $tarball.FullName 2>&1 | Out-String
                  Write-Host $loadOutput

                  # Extract image name from docker load output: "Loaded image: imagename:tag"
                  if ($loadOutput -match 'Loaded image:\s*(.+)') {
                    $loadedImage = $matches[1].Trim()
                    Write-Host "Loaded image: $loadedImage"
                    Write-Host "##vso[task.setvariable variable=LOADED_IMAGE]$loadedImage"
                  } else {
                    Write-Error "Failed to extract loaded image name from docker output"
                    exit 1
                  }
                displayName: 'Load container image'

              - pwsh: |
                  $image = $env:LOADED_IMAGE
                  if (-not $image) {
                    Write-Error "LOADED_IMAGE variable not set"
                    exit 1
                  }

                  Write-Host "Scanning: $image"

                  trivy image `
                    --severity '${{ parameters.containerSeverities }}' `
                    --format sarif `
                    --output "${{ parameters.artifactStagingDirectory }}/trivy-${{ replace(artifact.name, '-', '_') }}.sarif" `
                    --exit-code $(if ('${{ parameters.failOnCritical }}' -eq 'true') { 1 } else { 0 }) `
                    $image
                displayName: 'Scan with Trivy'
                continueOnError: ${{ parameters.continueOnError }}

              - task: PublishPipelineArtifact@1
                displayName: 'Publish Trivy results'
                condition: always()
                inputs:
                  targetPath: "${{ parameters.artifactStagingDirectory }}"
                  artifactName: "security-container-${{ replace(artifact.name, '-', '_') }}"

      # Job 4: IaC Scanning (Checkov)
      - ${{ if eq(parameters.runIacScan, true) }}:
        - job: IacScan
          displayName: 'IaC: Checkov'
          pool: ${{ parameters.pool }}
          steps:
            - checkout: self
              fetchDepth: 1
            - download: none

            - pwsh: |
                Write-Host "Running Checkov..."
                checkov `
                  --directory ${{ parameters.sourceDirectory }} `
                  --framework ${{ parameters.iacFrameworks }} `
                  --output sarif `
                  --output-file-path "${{ parameters.artifactStagingDirectory }}" `
                  --compact `
                  --quiet `
                  --soft-fail

                if ($LASTEXITCODE -ne 0) {
                  Write-Warning "Checkov found policy violations (exit code: $LASTEXITCODE)"
                }
              displayName: 'Run Checkov'
              continueOnError: true

            - task: PublishPipelineArtifact@1
              displayName: 'Publish Checkov results'
              inputs:
                targetPath: '${{ parameters.artifactStagingDirectory }}'
                artifactName: 'security-iac-checkov'
              condition: always()

      # Job 5: Secret Scanning (GitLeaks)
      - ${{ if eq(parameters.runSecretScan, true) }}:
        - job: SecretScan
          displayName: 'Secrets: GitLeaks'
          pool: ${{ parameters.pool }}
          steps:
            - checkout: self
              fetchDepth: ${{ parameters.secretScanDepth }}
            - download: none

            - pwsh: |
                Write-Host "Running GitLeaks..."
                gitleaks detect `
                  --source ${{ parameters.sourceDirectory }} `
                  --report-format sarif `
                  --report-path "${{ parameters.artifactStagingDirectory }}/gitleaks.sarif" `
                  --verbose `
                  --exit-code 0

                # GitLeaks exit codes: 0=no leaks, 1=leaks found, 2=error
                # We force exit 0 and check SARIF for findings instead
                if ($LASTEXITCODE -eq 2) {
                  Write-Error "GitLeaks encountered an error"
                  exit 1
                } elseif ($LASTEXITCODE -eq 1) {
                  Write-Warning "GitLeaks found potential secrets (will be reported in PR)"
                }
              displayName: 'Run GitLeaks'
              continueOnError: true

            - task: PublishPipelineArtifact@1
              displayName: 'Publish GitLeaks results'
              inputs:
                targetPath: '${{ parameters.artifactStagingDirectory }}/gitleaks.sarif'
                artifactName: 'security-secrets-gitleaks'
              condition: always()

      # Job 6: SBOM Generation (Syft) - parallel per container
      - ${{ if eq(parameters.runSbom, true) }}:
        - ${{ each artifact in parameters.containerArtifacts }}:
          - job: SBOM_${{ replace(artifact.name, '-', '_') }}
            displayName: 'SBOM: ${{ artifact.imageName }}'
            pool: ${{ parameters.pool }}
            steps:
              - checkout: none
              - download: none

              - task: DownloadPipelineArtifact@2
                displayName: 'Download container artifact'
                inputs:
                  artifactName: ${{ artifact.name }}
                  targetPath: '${{ parameters.pipelineWorkspace }}/containers'

              - pwsh: |
                  $tarball = Get-ChildItem "${{ parameters.pipelineWorkspace }}/containers" -Filter "*.tar" | Select-Object -First 1
                  if (-not $tarball) {
                    Write-Error "Container tarball not found"
                    exit 1
                  }

                  Write-Host "Loading container image from: $($tarball.FullName)"
                  $loadOutput = docker load -i $tarball.FullName 2>&1 | Out-String
                  Write-Host $loadOutput

                  # Extract image name from docker load output: "Loaded image: imagename:tag"
                  if ($loadOutput -match 'Loaded image:\s*(.+)') {
                    $loadedImage = $matches[1].Trim()
                    Write-Host "Loaded image: $loadedImage"
                    Write-Host "##vso[task.setvariable variable=LOADED_IMAGE]$loadedImage"
                  } else {
                    Write-Error "Failed to extract loaded image name from docker output"
                    exit 1
                  }
                displayName: 'Load container image'

              - pwsh: |
                  $image = $env:LOADED_IMAGE
                  if (-not $image) {
                    Write-Error "LOADED_IMAGE variable not set"
                    exit 1
                  }

                  $formats = '${{ parameters.sbomFormats }}'.Split(' ')

                  Write-Host "Generating SBOM for: $image"

                  foreach ($format in $formats) {
                    $outFile = "${{ parameters.artifactStagingDirectory }}/sbom-${{ replace(artifact.name, '-', '_') }}-$format.json"
                    syft "$image" -o "$format=$outFile"
                    Write-Host "Generated: $outFile"
                  }
                displayName: 'Generate SBOM'

              - task: PublishPipelineArtifact@1
                displayName: 'Publish SBOM'
                inputs:
                  targetPath: "${{ parameters.artifactStagingDirectory }}"
                  artifactName: "sbom-${{ replace(artifact.name, '-', '_') }}"

      # Job 7: Post Results to GitHub PR (only on PR builds)
      - job: PostToGitHubPR
        displayName: 'Post Results to GitHub PR'
        dependsOn:
          - SAST
          - SCA
          - ContainerScan_container_Dhadgar_Billing
          - ContainerScan_container_Dhadgar_Console
          - ContainerScan_container_Dhadgar_Discord
          - ContainerScan_container_Dhadgar_Files
          - ContainerScan_container_Dhadgar_Firewall
          - ContainerScan_container_Dhadgar_Gateway
          - ContainerScan_container_Dhadgar_Identity
          - ContainerScan_container_Dhadgar_Mods
          - ContainerScan_container_Dhadgar_Nodes
          - ContainerScan_container_Dhadgar_Notifications
          - ContainerScan_container_Dhadgar_Secrets
          - ContainerScan_container_Dhadgar_Servers
          - ContainerScan_container_Dhadgar_Tasks
          - IacScan
          - SecretScan
        condition: and(always(), eq(variables['Build.Reason'], 'PullRequest'))
        pool: ${{ parameters.pool }}
        steps:
          - checkout: none

          # Download all security artifacts
          - task: DownloadPipelineArtifact@2
            displayName: 'Download SAST results'
            continueOnError: true
            inputs:
              artifactName: 'security-sast-semgrep'
              targetPath: '$(Pipeline.Workspace)/security-artifacts'

          - task: DownloadPipelineArtifact@2
            displayName: 'Download SCA results'
            continueOnError: true
            inputs:
              artifactName: 'security-sca-owasp'
              targetPath: '$(Pipeline.Workspace)/security-artifacts'

          - task: DownloadPipelineArtifact@2
            displayName: 'Download Container scan results'
            continueOnError: true
            inputs:
              pattern: 'security-container-*'
              targetPath: '$(Pipeline.Workspace)/security-artifacts'

          - task: DownloadPipelineArtifact@2
            displayName: 'Download IaC scan results'
            continueOnError: true
            inputs:
              artifactName: 'security-iac-checkov'
              targetPath: '$(Pipeline.Workspace)/security-artifacts'

          - task: DownloadPipelineArtifact@2
            displayName: 'Download Secret scan results'
            continueOnError: true
            inputs:
              artifactName: 'security-secrets-gitleaks'
              targetPath: '$(Pipeline.Workspace)/security-artifacts'

          # Post results to GitHub PR
          - task: PowerShell@2
            displayName: 'Post findings to GitHub PR'
            env:
              GITHUB_TOKEN: $(GITHUB_PAT)
            inputs:
              targetType: 'filePath'
              filePath: '$(Build.SourcesDirectory)/scripts/Post-SecurityFindings.ps1'
              arguments: >
                -GitHubToken $env:GITHUB_TOKEN
                -RepoOwner "$(Build.Repository.Name.Split('/')[0])"
                -RepoName "$(Build.Repository.Name.Split('/')[1])"
                -PullRequestNumber $(System.PullRequest.PullRequestNumber)
                -ArtifactsPath "$(Pipeline.Workspace)/security-artifacts"
                -BuildUrl "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)&view=results"
              pwsh: true

      # Job 8: Publish SARIF to Microsoft Security DevOps (for Extensions UI)
      - job: PublishToSecurityDevOps
        displayName: 'Publish SARIF to Security Extensions'
        dependsOn:
          - SAST
          - SCA
          - ContainerScan_container_Dhadgar_Billing
          - ContainerScan_container_Dhadgar_Console
          - ContainerScan_container_Dhadgar_Discord
          - ContainerScan_container_Dhadgar_Files
          - ContainerScan_container_Dhadgar_Firewall
          - ContainerScan_container_Dhadgar_Gateway
          - ContainerScan_container_Dhadgar_Identity
          - ContainerScan_container_Dhadgar_Mods
          - ContainerScan_container_Dhadgar_Nodes
          - ContainerScan_container_Dhadgar_Notifications
          - ContainerScan_container_Dhadgar_Secrets
          - ContainerScan_container_Dhadgar_Servers
          - ContainerScan_container_Dhadgar_Tasks
          - IacScan
          - SecretScan
        condition: always()
        pool: ${{ parameters.pool }}
        steps:
          - checkout: none

          # Download all SARIF artifacts
          - task: DownloadPipelineArtifact@2
            displayName: 'Download all security artifacts'
            continueOnError: true
            inputs:
              itemPattern: '**/*.sarif'
              targetPath: '$(Pipeline.Workspace)/sarif-results'

          # Publish SARIF files as CodeAnalysisLogs artifact
          # Microsoft Security DevOps extension automatically discovers this artifact
          - task: PublishBuildArtifacts@1
            displayName: 'Publish SARIF to CodeAnalysisLogs'
            continueOnError: true
            inputs:
              PathtoPublish: '$(Pipeline.Workspace)/sarif-results'
              ArtifactName: 'CodeAnalysisLogs'
              publishLocation: 'Container'
